% ---------------------------------------------------------------------------- %
\section{Firmware \Sensor}
\label{sec:firmware:sensor}
% ---------------------------------------------------------------------------- %

Als  CPU auf  dem  Sensor agiert  wie im  Abschnitt~\ref{sec:hw:sensorplatine}
erw\"ahnt ein  Atmel Smart ARM  Cortex M0+ gew\"ahlt.   Die Firmware ist  in C
geschrieben.

\subsection{Benutze Bibliotheken}

Es wird komplett freie Software verwendet, weswegen zum bauen der Binaries GNU
Makefiles benutzt werden.

Die  Firmware  ist  auf  dem Atmel  Software  Framework  (ASF)  aufgebaut. Das
ASF  f\"uhrt  einen   Hardware  Abstraction  Layer  (HAL)   ein,  welcher  die
Hardware-Bl\"ocke der einzelnen Atmel CPUs  in einfache Interfaces in Form von
C-Funtionen abstrahiert. Um die g\"angigen  ARM-Schnittstellen zu nutzen, wird
CMSIS im  ASF  verwendet. Das  ASF  darf  f\"ur  Atmel  Chips  ohne  weiteres
verwendet werden, solange die Copyright Bemerkungen nicht entfernt werden.

\subsection{Die Firmware}

Die Firmware besteht im Kern aus einer simplen main() Funktion welche in einer
Endlosschleife l\"auft. Abbildung~\ref{fig:sensor:firmware:mainloop} zeigt sehr gut, wie diese Schleife aufgebaut ist.

\begin{figure}[h!tb]
\input{images/software/sensorProcess.tex}
\caption{Main Loop der Sensorfirmware}
\label{fig:sensor:firmware:mainloop}
\end{figure}

\subsubsection{UART}
\label{subs:UART}

Die Endlosschleife  \"uberpr\"uft zuerst, ob Daten  \"uber die  UART empfangen
wurden,   sprich   Anweisungen  vom   Master   oder   Antworten  von   anderen
Sensoren. Ist  das  der  Fall,  so  wird  darauf  reagiert.
Zuerst wird überprüft ob das Paket auch für den Sensor bestimmt war. Falls das erste Byte 0 ist, war das Paket für den Master bestimmt. Falls es 1 ist, so war das paket für einen Sensor bestimmt. Um zu bestimmen ob das Paket für sich selbst bestimmt war, prüft die Firmware, ob die nächsten 4 empfangenen Bytes der eigenen ID entsprechen. Hier ist wichtig, dass alle Daten Little Endian codiert sind.
Falls das Paket tatsächlich für den Sensor bestimmt war, so wertet er nun den Befehl aus und reagiert darauf. Im Normalfall bedeutet dies, dass die  UART die  gemittelten Daten der letzten 64 Messwerte an den Master adressiert und verschickt. Hierzu wird ein Datenpakt wie es in Abbildung~\ref{fig:sensor:firmware:datenpaket} zu sehen ist verschickt:

\begin{figure*}[ht!]
  \centering
  \begin{bytefield}[bitwidth=2em]{8}
    \bitheader{0,7} \\
        \colorbitbox{gray!50}{black}{8}{Indikatorbyte}\\
    \begin{rightwordgroup}{\sffamily Adresse}
        \colorbitbox{solarized-base2}{solarized-base02}{8}{Adressbyte 0} \\
        \colorbitbox{solarized-base2}{solarized-base02}{8}{Adressbyte 1} \\
        \colorbitbox{solarized-base2}{solarized-base02}{8}{Adressbyte 2} \\
        \colorbitbox{solarized-base2}{solarized-base02}{8}{Adressbyte 3}
    \end{rightwordgroup} \\
    \colorbitbox{solarized-magenta}{solarized-base3}{8}{Spannungsbyte 0}\\
    \colorbitbox{solarized-magenta}{solarized-base3}{8}{Spannungsbyte 1}\\
    \colorbitbox{solarized-blue}{solarized-base3}{8}{CRCbyte 0}\\
    \colorbitbox{solarized-blue}{solarized-base3}{8}{CRCbyte 1}\\
    \colorbitbox{solarized-blue}{solarized-base3}{8}{CRCbyte 2}\\
    \colorbitbox{solarized-blue}{solarized-base3}{8}{CRCbyte 3}\\
  \end{bytefield}
  \caption{Aufbau eines Datenpakets}
  \label{fig:sensor:firmware:datenpaket}
\end{figure*}

Damit der  Empf\"anger eines  Paketes erkennen kann  dass es  keine Technische
St\"orung  beim  \"ubertragen  gab  und  er falsche  Daten  liest,  wird  eine
Pr\"ufsumme (CRC)  der zu  verschickenden Daten mitgeschickt.   Um die  CRC zu
berechnen  wird  zuerst  das  Datenpaket  zusammengestellt. Davon  wird  dann
mithilfe des  ASF eine Pr\"ufsumme  erstellt und an das  bestehende Datenpaket
angeh\"angt. Dann wird das Datenpaket per UART verschickt.

\subsubsection{Sensor}
\label{subs:Sensor}

Der  Spannungssensor selbst  wird  mittels Analog  Digital  Konverters (  ADC)
verwirklicht.  Daf\"ur  wird mithilfe des ASF  ein 12 Bit ADC  ausgelesen und
von  diesen Werten  ein Moving  Average  erstellt.  Deshalb  kommt an  zweiter
Stelle in der Endlosschleife ein Lesevorgang  auf dem ADC.  Dann wird mithilfe
des sogenannten Cascaded Integrator–Comb Filters der aktuelle Moving Average
berechnet. Die Formel~\ref{eq:hogenauer} zeigt gut wie dies berechnet wird.
%(TODO: ref to https://en.wikipedia.org/wiki/Cascaded_integrator%E2%80%93comb_filter)

\begin{equation}\label{eq:hogenauer}
    \begin{split}
        y[n] &= \sum_{k=0}^{RM-1} x[n-k] \\
             &= y[n-1] + x[n] - x[n-RM].
    \end{split}
\end{equation}

Dieser Moving Average wird nun per UART verschickt.

\subsubsection{Statusanzeige}
\label{subs:Statusanzeige}

Damit man  gut sieht  ob der  Sensor noch korrekt  leuchtet, kommt  an letzter
Stelle der Endlosschleife noch ein simples Toggeln der LED, so dass man sieht,
ob etwas nicht stimmt, falls es einmal nicht mehr toggeln sollte.

\subsection{Open On Chip Debugger}

Zum Programmieren der  CPUs haben wir OpenOCD gew\"ahlt. Auch  hier ist wieder
anzumerken, dass es ein St\"uck freie Software ist. OpenOCD ist extrem leicht
zu erweitern und unterst\"utzt eine grosse Breite an Programmierschnittstellen
wie den STLinkv2 oder den Segger J-Link. Es werden Protokolle wie JTag und SWD
ohne spezielle Konfigurationen unterst\"utzt. Ebenfalls gibt es einen Reichtum
an Chips, die unterst\"utzt sind.

Da der  SAMD09 erst im  ersten Quartal 2016 auf  den Markt gekommen  ist, sind
sehr wenige Projekte vorhanden, welche ihn bereits benutzt haben.  Deshalb hat
OpenOCD unseren Chip zu Beginn nicht unterst\"utzt. Deshalb ist der bestehende
Treiber f\"ur Atmel-Chips von uns entsprechend erweitert worden.


Um   die   Kosten   tief   zu   halten,   haben   wir   einen   StLinkv2   als
Programmierschnittstelle verwendet. Auch  daf\"ur brauchte es einen  Patch des
Treibers,  da  der  STLinkv2  nur  32  Bit-Schreibbefehle  unterst\"utzt,  der
SAMD09  aber 16  Bit-Schreibbefehle  erwartet. Wir haben  deshalb einen  Patch
geschrieben,  welcher  16  Bit-Schreibbefehle  anstatt  32  Bit-Schreibbefehle
sendet.
